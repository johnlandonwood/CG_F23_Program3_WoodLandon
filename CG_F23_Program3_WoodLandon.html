<!DOCTYPE html>
<html>

<script id="vertex-shader" type="x-shader/x-vertex">
#version 300 es

in vec4 aPosition;
in vec2 aTexCoord;

out vec2 vTexCoord;

void main() { 
    gl_Position = aPosition;
    vTexCoord = aTexCoord;
}
</script>

<script id="normal-fragment-shader" type="x-shader/x-fragment">
#version 300 es

precision mediump float;

in vec2 vTexCoord;
uniform sampler2D texturevid;

out vec4 fColor;

void main() {
    fColor = vec4( texture( texturevid, vTexCoord ).rgb, 1. );
}
</script>

<script id="inversion-fragment-shader" type ="x-shader/x-fragment">
#version 300 es

precision mediump float;

in vec2 vTexCoord;
uniform sampler2D texturevid;

out vec4 fColor;

void main() {
    vec4 texColor = texture(texturevid, vTexCoord);
    
    // Invert the colors by subtracting each color component from 1.0
    vec3 invertedColor = vec3(1.0) - texColor.rgb;
    
    // Create the final color by combining alpha and inverted RGB
    fColor = vec4(invertedColor, texColor.a);
}
</script>

<script id="digital-halftoning-fragment-shader" type ="x-shader/x-fragment">
#version 300 es

precision mediump float;

in vec2 vTexCoord;
uniform sampler2D texturevid;

out vec4 fColor;

void main() {
    vec4 texColor = texture(texturevid, vTexCoord);
    
    // Convert color to grayscale using luminance (you can use other methods for grayscale conversion)
    float gray = dot(texColor.rgb, vec3(0.2126, 0.7152, 0.0722));
    
    // Threshold-based halftoning: if grayscale value > 0.5, set to white; otherwise, set to black
    float threshold = 0.5;
    float halftoneValue = step(threshold, gray);
    
    // Output black or white depending on the halftoneValue
    fColor = vec4(vec3(halftoneValue), texColor.a);
}    
</script>

<script id="distortion-fragment-shader" type="x-shader/x-fragment">
#version 300 es

precision mediump float;

in vec2 vTexCoord;
uniform sampler2D texturevid;

out vec4 fColor;

void main() {
    // Retrieve the texture color at the modified texture coordinates
    vec2 distortedTexCoord = vTexCoord + vec2(sin(vTexCoord.y * 30.0), cos(vTexCoord.x * 20.0)) * 0.02;
    vec4 texColor = texture(texturevid, distortedTexCoord);
    fColor = texColor;
}
</script>

<script id="fisheye-fragment-shader" type="x-shader/x-fragment">
#version 300 es

precision mediump float;

in vec2 vTexCoord;
uniform sampler2D texturevid;

out vec4 fColor;

void main() {
    // Define the center point of the image as the origin (0.5, 0.5)
    vec2 center = vec2(0.5, 0.5);

    // Calculate the vector from the center to the current texture coordinate
    vec2 diff = vTexCoord - center;

    // Calculate the distance from the center
    float distance = length(diff);

    // Define the radius of the fish-eye effect
    float radius = 0.5;

    // Calculate the ratio based on the distance and radius
    float ratio = 2.0 * distance / radius;

    // Apply fish-eye distortion to the texture coordinates
    vec2 fishEyeCoords = center + normalize(diff) * radius * (ratio / (1.0 + pow(ratio, 2.0)));

    // Retrieve the color from the distorted texture coordinates
    vec4 texColor = texture(texturevid, fishEyeCoords);

    fColor = texColor;
}
</script>

<video id="webcamVideo" style="display: none;"></video>

<body>
    <canvas id="gl-canvas" width="700" height="700"> </canvas> 
    <br/>
    <p>Select fragment shader effect: </p>
    <select id="shaderSelector">
        <option value="0" selected="selected">No effect</option>
        <option value="1">Inversion Shader</option>
        <option value="2">Digital Halftoning Shader</option>
        <option value="3">Squiggly Sin/Cos Shader</option>
        <option value="4">Fisheye Lens Shader</option>
    </select>
</body>

<script src="../Common/initShaders.js"></script>
<script type="text/javascript" src="CG_F23_Program3_WoodLandon.js"></script>

